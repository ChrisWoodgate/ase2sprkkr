from ..common.conf_containers import Section
from functools import partial

class PotentialSection(Section):
    """ A generic class for a section in a potential """

    def _set_from_atoms(self, atoms, write_io_data):
        """ This function should be called before potential file writing to set the propper values to the section.

        Parameters
        ----------
        atoms : sprkkr.ase.SprKkrAtoms
          Atoms that will be used to create

        write_io_data: sprkkr.potential.WriteIoData
          Object for storing values generated by one section to be (reused in another) - e.g. scaling constants or numbering of meshes etc...
        """
        pass

    def _update_atoms(self, atoms, read_io_data):
        """
        This function should be called after potential file reading to set the values of Atoms object to the ones from the readed file.

        Parameters
        ----------
        atoms : sprkkr.ase.SprKkrAtoms
          Atoms, whose properties should be set to the values from readed file. Can be None in some sections, then the object will be created
        read_io_data: sprkkr.potential.ReadIoData
          Object for storing values from one section to be used in another one. This mechanism is used to be the sections as independent (and independently testable) as they can be.


        Return
        ------
        atoms: None or sprkkr.ase.SprKkrAtoms
          If the function creates a new Atoms obejct (either when None has been passed to the atoms args, or when the atoms cannot be adapted to the values readed from the file - e.g. when number of atoms differs) it should return it.
        """
        return None

    def _depends_on(self):
        """ The order of processing of sections during reading can be different than the order during a write. So, if the function should not be processed before given named sections, name then.

        Return
        ------
        prerequisites: [ str, str, ... ]
        """

        return self._definition.depends_on()

class UniqueListSection(PotentialSection):
    """ Class in a section, which data is list of something,
        e.g. of meshes, reference systems etc. Following class
        properties has to be redefined in the descendants
    """

    """ Name of the property of write_io_data to get the list """
    _value_name = None
    """ Class, that should be created from the list of data """
    _value_class = None


    def _set_from_atoms(self, atoms, write_io_data):
        ul = getattr(write_io_data, self._value_name)
        self['DATA'].set([ i.to_tuple() for i in ul.iter_unique()])

    def _update_atoms(self, atoms, read_io_data):
        creator = getattr(self._value_class, 'from_tuple', self._value_class)
        read_io_data[self._value_name] = [creator(*i) for i in self['DATA']()]


class ASEArraySection(PotentialSection):
    """ Section, that get and set the given ase array """

    def has_any_value(self):
        return self['DATA'] is not None

    def _depends_on(self):
        """ These sections can be processed after that the Atoms object
            is created """
        return super()._depends_on() + ['SITES']

    def _set_from_atoms(self, atoms, _):
        data = self['DATA']
        try:
          value = atoms.get_array(self._definition.array_name)
        except KeyError:
          if self._definition.is_optional:
             value = None
          else:
             value = data._definition.type.zero_data(len(atoms.positions))
        data.set(value)

    def _update_atoms(self, atoms, _):
        value = self['DATA']()
        atoms.set_array(self._definition.array_name, value)
