<html>
<head>
<style>
	body {
		max-width: 50em;
		text-align: justify;
		margin: auto;

	}
	pre {
	background: rgb(205,205,205);
	padding-left: 1em;
	margin-
	}
</style>
</head>
<body>
<h1>ASE2SPRKKR</h1>
		ASE2SPRKKR package is the interface to allow use of the <a href="https://www.ebert.cup.uni-muenchen.de/index.php/en/software-en/13-sprkkr" target="_blank">SPR-KKR package</a> to electronic structure calculation within <a href="https://wiki.fysik.dtu.dk/ase/" target="_blank">Atomic Simulation Environment</a> (abbreviated as ASE) --- Python tool that integrates the various tools for electronic structure calculation.

<h2>Usefull links</h2>
<ul>
	<li><a target="_blank" href='https://software.pan-data.eu/software/111/spr-kkr'>SPR-KKR</a>
	<li><a target="_blank" href='https://wiki.fysik.dtu.dk/ase/'>ASE - Atomic SImulation Environment</a>
	<li><a target="_blank" href='https://ase2sprkkr.github.io/ase2sprkkr/'>Online version of this documentation</a>
	<li><a target="_blank" href='https://github.com/ase2sprkkr/ase2sprkkr/'>GitHub repository of the ASE2SPRKKR package</a>
</ul>

<h2>Installation</h2>
Just run <pre>install.sh</pre> For more verbose documentation, please see <a href='README.md.html'>READ ME</a>

You are encouraged to run the test after installation, using
<pre>
make test
</pre>

<h2>Usage</h2>
The package allows us to define the problem to be computed using Python and ASE. The current version of the package is aimed primarily at defining the problem. The capabilities of obtaining the results and their postprocessing are still limited: it is assumed, that the user of the package is experienced with SPR-KKR package and is capable to analyze the resulting output of SPR-KKR.

Bellow, you can see several basic examples of how to use the package.

<h3>Computing a bulk material</h3>
The basic usage of the package is to use ASE to define the computed structure and, using SPR-KKR calculator, run the calculation:
<pre>
from ase.build import bulk
from ase2sprkkr.sprkkr.calculator import SPRKKR

atoms = bulk('Li')
calculator = SPRKKR(atoms=atoms)
calculator.calculate()
</pre>
Calculation requires to have SPR-KKR in the PATH. In some cases, SPR-KKR is compiled with a version (and/or hostname) suffix. In this case, please
define environmental variable <tt>SPRKKR_COMMAND_SUFFIX</tt>  if the SPR-KKR executable for SCF task has the name <tt>kkrscf8.6</tt>, please run
(the example is for the bash shell):
<pre>
export SPRKKR_EXECUTABLE_SUFFIX=8.6
</pre>

<h3>Defining the material properties</h3>
Most of the properties of the material can be defined as is described in the <a href='https://wiki.fysik.dtu.dk/ase/' target='_blank'>ASE documentation.</a>
However, ASE do not support occupation of the sites. To define it, you most promote the atoms object to the ASE2SPRKKR one. It is done automatically,
if you pass the atoms object into the SPRKKR calculator constructor, however, you can do it manually, if needed.
<pre>
from ase.build import bulk
from ase2sprkkr.sprkkr.sprkkr_atoms import SPRKKRAtoms
atoms=bulk('LiCl', 'rocksalt', a=5.64) * (2, 1, 1)
atoms = SPRKKRAtoms.promote_ase_atoms(atoms)
</pre>
Promoted atoms have the sites attribute, which is an array of the sites in the primitive cell.
If two sites are indistinguishable, they share the sites object --- this is computed automatically according to the symmetry of the structure (see the
SPRKKRAtoms.compute_sites_symmetry method).

Sites object in the sites array holds all the SPRKKR specific properties of the sites.
You can change the occupation of a given site by calling the <tt>Site.occupation.set</tt> method:
<pre>
atoms.sites[3].occupation.set({'Cl':0.5, 'I' : 0.5 })
</pre>
Atomic type can be given both by a chemical symbol or atomic number. You can also just add an atomic type
to the site:
<pre>
atoms.sites[3].occupation['Br'] = 0.2
</pre>
-- the occupations of the currently presented atomic types are lowered accordingly --- or just query
the occupation of a given atomic type:
<pre>
atoms.sites[3].occupation['Br']
</pre>

Some codes stores the occupation information in <tt>atoms.info['occupancy']</tt>. To allow interoperability with these codes the occupancy
is readed from this array when <tt>SPRKKRAtoms.promote_ase_atoms</tt> is called and the <tt>atoms.info['occupancy']</tt> is updated each
time the <tt>atoms.sites[x].occupation</tt> is changed.

<h3>Reading the results</h3>
Some of the results of the computation are returned by the calculate method (see e.g. ase2sprkkr.input_parameters.outputs.kkrscf_process_output_reader.ScfResult).

<pre>
out = calculator.calculate()
print(f"Energy is {out.energy}")
print(f"There were {len(out.iterations}) iterations")
print(f"The convergence error is {out.iterations[-1]['error']}")
print(f"The moments are {out.last_iteration['moment']}")
</pre>
For the SCF task, you can request the newly-created potential file, either by filename,
or by a Potential object, from which you can read the other results in a text format
(you are encouraged to contribute to ase2sprkkr to define the format of not-yet-implemented
sections of potential).
<pre>
print(f"Potential has been saved to: {out.potential_filename}")
potential = out.potential
print(potential.CHARGE())
</pre>

<h3>Setting the task type and input parameters</h3>
SPRKKR allows users to compute different tasks and each task can receive many input parameters.
The default task (if none is specified) is SCF: to do a self-consistent
cycle to compute the wavefunctions.

You can either choose the task and its parameters either during creating the calculator
via <tt>input_parameters</tt> argument:
<pre>
calculator = SPRKKR(atoms=atoms, input_parameters='PHAGEN', options={'NE': 5})
</pre>
or one-time in the <tt>calculate</tt> methods:
<pre>
calculator.calculate(input_parameters='PHAGEN', options={'NE': 5})
</pre>

The <tt>input_parameters</tt> argument accepts either a name of one of the predefined task
(SCF, PHAGEN, ARPES, DOS), which uses a predefined set of parameters for the task,
the filename (containing either dot or slash) from where the parameters will be loaded
or the <tt>InputParameters</tt> object (see the later example).
<pre>
calculator = SPRKKR(atoms=atoms, input_parameters='PHAGEN', options={'NE': 5})
calculator = SPRKKR(atoms=atoms, input_parameters='./input.inp', options={'NE': 5})
</pre>

You can see and modify the input parameters of a calculator using its <tt>set</tt> and <tt>get</tt>
methods:
<pre>
calculator.set(NE = 5)
print(calculator.get('NE'))
</pre>

We can see, that both <tt>set</tt> and <tt>get</tt> methods and <tt>options</tt> parameters do not require
to specify the section names (see the SPR-KKR manual).
They get/set the first (known, according to the definition of the
input parameters) parameter with the given name. However, if it is necessary to avoid a name conflict,
you can either use
<tt>SECTION.VALUE</tt> notation
<pre>
calculator.set({'ENERGY.NE':6})
print(calculator.get('ENERGY.NE'))
</pre>
...or use the <tt>input_parameters</tt> property of the calculator.
Through this property (which contains <tt>InputParameter</tt> object) the sections
and their parameters are directly acessible.
During interactive work, you can use tab-completion to see the sections and their parameters.
<pre>
calculator = SPRKKR(input_paramters = 'SCF')
calculator.input_parameters.ENERGY.NE = 5
print(calculator.input_parameters.ENERGY.NE())
calculator.input_parameters.ENERGY.&lt;tab&gt;
</pre>
The sections and their parameters have their names in uppercase (at least partialy, e.g. <tt>ImE</tt>).

<h4>Working with InputParameters object</h4>

You can also directly create the <tt>InputParameters</tt> object and pass
it into the <tt>input_parameters</tt> property,
calculator constructor or to the <tt>calculate</tt> method
<pre>
from ase2sprkkr.input_parameters.input_parameters import InputParameters
input_parameters = InputParameters.create('SCF')
input_parameters.ENERGY.NE = 5
input_parameters.TAU.NKTAB = 13
calculator = SPRKKR(atoms=atoms, input_parameters=input_parameters)
</pre>
You can also add your own custom (not-predefined) parameters and sections, if there is a need.
<pre>
input_parameters.add('MY_CUSTOM_SECTION')
input_parameters.MY_CUSTOM_SECTION.add('MY_CUSTOM_VALUE', 17)
</pre>

If you work with input parameters readed from an already created input file, you can use
the <tt>calculate</tt> method to avoid the necessity to create the calculator:
<pre>
input_parameters = InputParameters.from_file('input.inp')
input_parameters.calculate()
</pre>

The input parameters can be set or reset (to the task-predefined values, to the values in
<tt>InputParameters</tt> object or to the values contained in an input file)
via the calculator <tt>input_parameters</tt> property.
<pre>
calculator.input_parameters = input_parameters
calculator.input_parameters = 'SCF'
calculator.input_parameters = './input_file.inp'
</pre>


<h4>Running more subsequent tasks</h4>
A common usecase is to run more subseuent task with the same atomic structure. To do so,
you can either modify the <tt>input_parameters</tt> and <tt>potential_file</tt> of a calculator
(the <tt>out.potential_filename</tt> property contains the name of the `converged potential')
<pre>
calculator = SPRKKR(atoms=atoms, input_parameters='SCF')
out = calculator.calculate()
calculator.calculate(input_parameters='PHAGEN', potential=out.potential_filename)
</pre>

...or you can use calculator associated with the converged potential, which is available in the <tt>output.calculator</tt> property
of a SCF task result:
<pre>
out = calculator.calculate(input_parameters='SCF')
out.calculator.calculate(input_parameters='PHAGEN')
</pre>


<h4>Reading the input file</h4>
If you want to repeat a calculation, you can read (and modify) the input parameters from an existing input file. In this case, it may be
useful to use the method <tt>calculate</tt> of InputParameters object to avoid the necessity to create the calculator.
<pre>
input_parameters = InputParameters.from_file('an_input_file.inp')
input_parameters.calculate(potential='a_potential_file.pot')
</pre>
or you can of course just set the calculator <tt>input_parameters</tt> property to the filename, or pass the filename as <tt>input_parameters</tt> argument to its constructor or <tt>calculate</tt> method.

<h3>Working with potential files</h3>
The most of the properties that determine the computed problem in SPR-KKR are given in potential file. The potential file is created from the atoms automatically by the calculator. However, it is possible to pass your own manually (or earlier) created
potential file to the calculation:
<pre>
calculator.calculate(potential = 'my_potential_file')
</pre>
or to create the Potential object manually from ASE atoms object and to alter/check its properties before the computation
<pre>
from ase2sprkkr.potential.potentials import Potential
potential = Potential.from_atoms(atoms)
print(potential.GLOBAL_SYSTEM_PARAMETER.IREL())
calculator.calculate(potential = potential)
</pre>

<h3>Generating the input files</h3>
If you just want to generate the input files (input and potential ones) and not to run the calculation, you can
use method <tt>calculator.save_input</tt>. It acceps, same as the method <tt>calculate</tt>, the
arguments to specify the filenames of the task and potential (and, for the <tt>calculate</tt> method, output) file.
<pre>
calculator.calculate(input_file = ..., potential_file = ..., output_file = ....)
</pre>
If you pass <tt>None</tt> to any of the arguments above, the temp file will be used. String argument will be interpreted as filename where to store the input and output files. However, these strings are interpereted as templates, where the following placeholders can be used:
<table border>
	<tr><td>%d</td><td>Current date and time</td></tr>
	<tr><td>%t</td><td>InputParameters name (SCF, PHAGEN, ...)</td></tr>
	<tr><td>%a</td><td>Chemical structure (e.g. CF4)</td></tr>
	<tr><td>%c</td><td>Counter, starting from one, advanced each function call (that uses the counter)</td></tr>
</table>

<h3>A note about potentials and atoms and input_parameters</h3>
<p>Using the calculator, one can (in various methods) specify either atoms object or/and potential, which can lead to the duplicity of the information provided to the calculator. Therefore, there is the following logic behind the scenes:</p><p>
If the potential is not provided, it is created according to the atoms object (which in this case has to be supplied). If the potential is given by a filename, it is used "as is", while if it is given by an object (of a <tt>Potential</tt> class), this object is updated according to the atoms object (if the latter is supplied). The special value False for the potential means to use the potential file specified by the task: in this case, the InputParameters object or task file (with specified potential) has to be supplied (as the argument).
</p>
<p>The input parameters can be given either by a filename (containing the "input file"), by object (of class <tt>InputParameters</tt>), or by string (which creates the <tt>InputParameters</tt> object containing the predefined values). If the parameters are given by object, the input file is created. If it is given by filename, the file is readed and modified only if a modification is required, i.e. if the potential filename should be written into it (i.e. the potential argument of <tt>save_input</tt>, <tt>run</tt> or <tt>calculate</tt> methods is not False, or if the non-empty options argument is specified).</p>

<p>Note, that:
<ul><li>
		If the potential is set to an SPRKKR calculator (either by the <tt>potential</tt> property setter or in the constructor), the atoms object is created from the potential (and stored in the <tt>calculator.atoms</tt> property). However, this object does not reflect the changes made to the potential thereafter.
		<li>After the computation of the SCF task, the result provide a new potential (in the <tt>result.potential</tt> property), the old one is not updated, nor the calculator potential property.
</ul>

<h3>MPI calculations</h3>
You can use MPI in your calculations using the <tt>mpi</tt> parameter (of both the calculator constructor and <tt>calculate</tt> method).
On clusters, where the number of processes is determined by the batch system, you can just pass True to the argument,
otherwise supply an integer that denotes the number of wanted processes.

The mpi runner is detected automatically. If the detection failed, the message is printed and non-MPI calculation is runned.
In this case, or if you want to use a different MPI implementation, you have to pass the correct mpi runner and its arguments
to the calculator:
<pre>
calculator = SPRKKR(atoms=atoms, mpi = 'path/to/my/mpirunner')
calculator = SPRKKR(atoms=atoms, mpi = ['path/to/my/mpirunner','-np','4'])
</pre>
In the case you use common mpi runners (<tt>mpirun</tt>, <tt>mpirun.openmpi</tt> or <tt>mpirun.mpich</tt>), you can
either pass just <tt>True</tt> to the <tt>mpi</tt> parameter - if the runner can detect the number of processes, e.g.
in a cluster environment - or integer that denotes the number of requested processes.
<pre>
calculator = SPRKKR(atoms=atoms, mpi=True)
calculator = SPRKKR(atoms=atoms, mpi=4)
</pre>


<h3>Bundled tools</h3>
In <tt>tools</tt> subdirectory of the package, there is a tool visualise_in_struct for visualisation
of the surfaces computed by the SPR-KKR package. To view a surface, you can run
<pre>
python visualise_in_struct.py -i in_structure.inp -p potential.pot
</pre>
where <tt>potential.pot</tt> is a potential file and <tt>in_structure.inp</tt> is a file containing the
structure of the surface. Run
<pre>
python visualise_in_struct.py --help
</pre>
for further options of this tool.

<h2>Classes and functions documentation</h2>
Please visit the link  <a href='./gen/index.html'>Documentation of classes and functions</a>. You can rebuild it using
<pre>
make docs
</pre>
Sphinx and md2html will be needed.

</body>
</html>
